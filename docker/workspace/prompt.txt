
The method looks like: 
```java
    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
        if (cs1 == cs2) {
            return true;
        }
        if (cs1 == null || cs2 == null) {
            return false;
        }
        if (cs1 instanceof String && cs2 instanceof String) {
            return cs1.equals(cs2);
        }
        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
    }

```

The test cases covering given method looks like: 
```java
    @Test
    public void testEqualsCS2() {
        Assert.assertTrue(StringUtils.equals("abc", new StringBuilder("abc")));
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abc"), "abcd"));
        Assert.assertFalse(StringUtils.equals("abcd", new StringBuilder("abc")));
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abc"), "ABC"));
    }
    @Test
    public void testEqualsString() {
        Assert.assertTrue(StringUtils.equals(null, null));
        Assert.assertFalse(StringUtils.equals("abc", null));
        Assert.assertFalse(StringUtils.equals(null, "abc"));
        Assert.assertTrue(StringUtils.equals("abc", "abc"));
        Assert.assertFalse(StringUtils.equals("abc", "abcd"));
        Assert.assertFalse(StringUtils.equals("abcd", "abc"));
        Assert.assertFalse(StringUtils.equals("abc", "ABC"));
    }
    @Test
    public void testEqualsCS1() {
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abc"), null));
        Assert.assertFalse(StringUtils.equals(null, new StringBuilder("abc")));
        Assert.assertTrue(StringUtils.equals(new StringBuilder("abc"), new StringBuilder("abc")));
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abc"), new StringBuilder("abcd")));
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abcd"), new StringBuilder("abc")));
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abc"), new StringBuilder("ABC")));
    }

```

Provide regression test cases that can kill more mutants of the given method by changing the input of the covering tests.
Only the input value of the method in each test should be changed.
You should insert all regression tests into the below format.
I have to parse your response, therefore the format below should appear only once in your response.

```java

```

```java
    @Test
    public void testEqualsCS2() {
        Assert.assertFalse(StringUtils.equals("abc", new StringBuilder("abcd"))); //mutant: append a character to cs2
        Assert.assertTrue(StringUtils.equals(new StringBuilder("abcd"), "abcd")); //mutant: remove a character from cs1
        Assert.assertFalse(StringUtils.equals("abcd", new StringBuilder("abc"))); //mutant: append a character to cs1
        Assert.assertTrue(StringUtils.equals(new StringBuilder("abc"), "ABC")); //mutant: change the case of cs2
    }
    @Test
    public void testEqualsString() {
        Assert.assertFalse(StringUtils.equals("abc", null)); //mutant: change null to a non-null String
        Assert.assertFalse(StringUtils.equals(null, "abc")); //mutant: change null to a non-null String
        Assert.assertTrue(StringUtils.equals("abc", "abcd")); //mutant: append a character to cs2
        Assert.assertFalse(StringUtils.equals("abcd", "abc")); //mutant: append a character to cs1
        Assert.assertTrue(StringUtils.equals("abc", "ABC")); //mutant: change the case of cs2
    }
    @Test
    public void testEqualsCS1() {
        Assert.assertFalse(StringUtils.equals(null, new StringBuilder("abc"))); //mutant: change null to a non-null StringBuilder
        Assert.assertTrue(StringUtils.equals(new StringBuilder("abc"), new StringBuilder("abcd"))); //mutant: append a character to cs2
        Assert.assertFalse(StringUtils.equals(new StringBuilder("abcd"), new StringBuilder("abc"))); //mutant: append a character to cs1
        Assert.assertTrue(StringUtils.equals(new StringBuilder("abc"), new StringBuilder("ABC"))); //mutant: change the case of cs2
    }
```

The new regression test cases aim to kill additional mutants in the given method by changing the input values.

The method looks like: 
```java
    private static byte[] getBytes(final String string, final Charset charset) {
        if (string == null) {
            return null;
        }
        return string.getBytes(charset);
    }

```

The test cases covering given method looks like: 
```java
    @Test
    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {
        final String charsetName = "UTF-16LE";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);
        Assert.assertTrue(Arrays.equals(expected, actual));
    }
    @Test
    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {
        final String charsetName = "UTF-16BE";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);
        Assert.assertTrue(Arrays.equals(expected, actual));
    }
    @Test
    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {
        final String charsetName = "ISO-8859-1";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);
        Assert.assertTrue(Arrays.equals(expected, actual));
    }
    @Test
    public void testGetBytesUtf8() throws UnsupportedEncodingException {
        final String charsetName = "UTF-8";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);
        Assert.assertTrue(Arrays.equals(expected, actual));
    }
    @Test
    public void testGetBytesUtf16() throws UnsupportedEncodingException {
        final String charsetName = "UTF-16";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);
        Assert.assertTrue(Arrays.equals(expected, actual));
    }
    @Test
    public void testGetBytesUsAscii() throws UnsupportedEncodingException {
        final String charsetName = "US-ASCII";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = STRING_FIXTURE.getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);
        Assert.assertTrue(Arrays.equals(expected, actual));
    }

```

Provide regression test cases that can kill more mutants of the given method by changing the input of the covering tests.
Only the input value of the method in each test should be changed.
You should insert all regression tests into the below format.
I have to parse your response, therefore the format below should appear only once in your response.

```java

```

The additional regression test cases that can kill more mutants of the given method by changing the input of the covering tests are:

```java
    @Test
    public void testGetBytesUtf16LeWithNullInput() throws UnsupportedEncodingException {
        final String charsetName = "UTF-16LE";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = null;
        final byte[] actual = StringUtils.getBytesUtf16Le(null);
        Assert.assertArrayEquals(expected, actual);
    }
    
    @Test
    public void testGetBytesUtf16BeWithEmptyString() throws UnsupportedEncodingException {
        final String charsetName = "UTF-16BE";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = new byte[0];
        final byte[] actual = StringUtils.getBytesUtf16Be("");
        Assert.assertArrayEquals(expected, actual);
    }
    
    @Test
    public void testGetBytesIso8859_1WithWhitespace() throws UnsupportedEncodingException {
        final String charsetName = "ISO-8859-1";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = " ".getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesIso8859_1(" ");
        Assert.assertArrayEquals(expected, actual);
    }
    
    @Test
    public void testGetBytesUtf8WithUppercaseString() throws UnsupportedEncodingException {
        final String charsetName = "UTF-8";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = "HELLO".getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUtf8("HELLO");
        Assert.assertArrayEquals(expected, actual);
    }
    
    @Test
    public void testGetBytesUtf16WithSpecialCharacters() throws UnsupportedEncodingException {
        final String charsetName = "UTF-16";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = "@#$%".getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUtf16("@#$%");
        Assert.assertArrayEquals(expected, actual);
    }
    
    @Test
    public void testGetBytesUsAsciiWithNumbers() throws UnsupportedEncodingException {
        final String charsetName = "US-ASCII";
        testGetBytesUnchecked(charsetName);
        final byte[] expected = "12345".getBytes(charsetName);
        final byte[] actual = StringUtils.getBytesUsAscii("12345");
        Assert.assertArrayEquals(expected, actual);
    }
    
```
Note: I have inserted the additional regression test cases in the format you provided.
